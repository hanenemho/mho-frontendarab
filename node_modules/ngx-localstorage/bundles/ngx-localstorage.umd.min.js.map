{"version":3,"sources":["../../../../libs/ngx-localstorage/src/lib/utils.ts","../../../../libs/ngx-localstorage/src/lib/services/promisable.service.ts","../../../../libs/ngx-localstorage/src/lib/tokens/storage-config.ts","../../../../libs/ngx-localstorage/src/lib/tokens/storage-serializer.ts","../../../../libs/ngx-localstorage/src/lib/services/ngx-localstorage.service.ts","../../../../libs/ngx-localstorage/src/lib/services/storage-event.service.ts","../../../../libs/ngx-localstorage/src/lib/directives/ngx-localstorage.directive.ts","../../../../libs/ngx-localstorage/src/lib/classes/default-serializer.ts","../../../../libs/ngx-localstorage/src/lib/ngx-localstorage.module.ts","../../../../libs/ngx-localstorage/src/lib/decorators.ts"],"names":["setProperty","path","value","object","falsyTransformer","lastKeyIndex","length","i","key","constructKey","prefix","configuredPrefix","prefixToUse","defaultConfig","allowNull","isSerializer","prefixOrSerializer","undefined","serialize","PromisableService","configuration","defaultSerializer","this","prototype","count","Promise","resolve","reject","localStorage","error","getKey","index","Error","set","serializer","_this","remove","setItem","get","deserialize","getItem","removeItem","clear","NGX_LOCAL_STORAGE_CONFIG","InjectionToken","NGX_LOCAL_STORAGE_SERIALIZER","LocalStorageService","config","Object","assign","promisable","asPromisable","console","Injectable","args","providedIn","Inject","StorageEventService","_eventStream","BehaviorSubject","subscription","observableFromEvent","window","subscribe","ev","next","defineProperty","asObservable","pipe","filter","share","ngOnDestroy","closed","unsubscribe","LocalStorageDirective","er","lss","es","lsDebounce","lsInitFromStorage","lsStoredValue","EventEmitter","_valuePath","stream","indexOf","lsKey","newValue","nativeElement","lsFalsyTransformer","Array","isArray","split","ngAfterViewInit","_initKey","_initFromStorage","_hookEvent","id","name","lsEvent","_eventSubscription","debounceTime","reduce","obj","p","lsPrefix","then","emit","catch","err","storedValue","Directive","selector","ElementRef","Input","Output","DefaultSerializer","JSON","stringify","parse","NgxLocalStorageModule","parentModule","forRoot","ngModule","providers","provide","useValue","NgModule","imports","declarations","exports","useClass","decorators","type","Optional","SkipSelf","options","target","propertyDescription","service","nullTransformer","storageValue"],"mappings":"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","sourcesContent":["import { NgxLocalstorageConfiguration } from './interfaces/storage-configuration';\r\nimport { StorageSerializer } from './interfaces/storage-serializer';\r\n\r\n/**\r\n * Gets an objects property based on its path.\r\n * @param path Path to the property\r\n * @param object Object to access\r\n */\r\nexport const getProperty = (path: string[], object: any) =>\r\n  path.reduce((obj: any, p: any) => (!!obj) ? obj[p] : null, object);\r\n\r\n/**\r\n * Sets an objects property based on its path.\r\n * @param path Path to the property\r\n * @param value Value to set\r\n * @param object Object whose value to set\r\n * @param falsyTransformer optional transformer handling falsy values\r\n */\r\nexport const setProperty = (path: string[] | string, value: any, object: any, falsyTransformer?: () => any) => {\r\n  const lastKeyIndex = path.length - 1;\r\n  for (let i = 0; i < lastKeyIndex; ++i) {\r\n    const key = path[i];\r\n    if (!(key in object)) {\r\n      object[key] = {};\r\n    }\r\n    object = object[key];\r\n  }\r\n  object[path[lastKeyIndex]] = (!value || (typeof value === 'string' && value === 'false'))\r\n    && !!falsyTransformer ? falsyTransformer() : value;\r\n};\r\n\r\n/**\r\n * Constructs the storage key based on a prefix - if given - and the key itself\r\n */\r\nexport const constructKey = (key: string, prefix?: string, configuredPrefix?: string): string => {\r\n  const prefixToUse = prefix || configuredPrefix;\r\n  if (prefixToUse) {\r\n    return `${prefixToUse}_${key}`;\r\n  }\r\n  return key;\r\n}\r\n\r\n/**\r\n * The librarys default config.\r\n */\r\nexport const defaultConfig: NgxLocalstorageConfiguration = {\r\n  allowNull: true\r\n};\r\n\r\n/**\r\n * StorageSerializer Guard\r\n */\r\nexport const isSerializer = (prefixOrSerializer: string | StorageSerializer): prefixOrSerializer is StorageSerializer => {\r\n  return !!prefixOrSerializer && (prefixOrSerializer as StorageSerializer).serialize !== undefined;\r\n}\r\n","import { NgxLocalstorageConfiguration } from '../interfaces/storage-configuration';\r\nimport { StorageSerializer } from '../interfaces/storage-serializer';\r\nimport { constructKey, isSerializer } from '../utils';\r\n\r\n/**\r\n * Provides a Promise based service to access the localstorage.\r\n */\r\nexport class PromisableService {\r\n\r\n  /**\r\n   * Creates a new instance\r\n   */\r\n  constructor(\r\n    private readonly configuration: NgxLocalstorageConfiguration,\r\n    private readonly defaultSerializer: StorageSerializer\r\n  ) { }\r\n\r\n  /**\r\n   * Gets the number of entries in the applications local storage.\r\n   */\r\n  public count(): Promise<number> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        resolve(localStorage.length);\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Returns the nth (defined by the index parameter) key in the storage.\r\n   * The order of keys is user-agent defined, so you should not rely on it.\r\n   * @param index   An integer representing the number of the key you want to get the name of. This is a zero-based index.\r\n   */\r\n  public getKey(index: number): Promise<string | null> {\r\n    return new Promise<string | null>((resolve, reject) => {\r\n      if (index < 0) {\r\n        reject(new Error('index has to be 0 or greater'));\r\n      }\r\n      try {\r\n        resolve(localStorage.key(index));\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Adds the value with the given key or updates an existing entry.\r\n   * @param key     Key to store.\r\n   * @param value   Value to store.\r\n   * @param prefixOrSerializer  Optional prefix or serializer to overwrite the configured one.\r\n   * @param serializer  Optional serilizer.\r\n   */\r\n  public set(key: string, value: any, prefixOrSerializer?: string | StorageSerializer): Promise<boolean>;\r\n  public set(key: string, value: any, prefixOrSerializer: string | StorageSerializer): Promise<boolean>;\r\n  public set(key: string, value: any, prefixOrSerializer: string, serializer: StorageSerializer): Promise<boolean>;\r\n  public set(key: string, value: any, prefixOrSerializer?: string | StorageSerializer, serializer?: StorageSerializer): Promise<boolean> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n\r\n        const prefix = typeof prefixOrSerializer === 'string' ? prefixOrSerializer : undefined;\r\n        serializer = isSerializer(prefixOrSerializer)\r\n          ? (prefixOrSerializer as StorageSerializer)\r\n          : !!serializer\r\n            ? serializer\r\n            : this.defaultSerializer;\r\n\r\n        if (this.configuration.allowNull\r\n          || (!this.configuration.allowNull && value !== 'null' && value !== null && value !== undefined)) {\r\n          localStorage.setItem(constructKey(key, prefix, this.configuration.prefix), serializer.serialize(value));\r\n        } else {\r\n          return this.remove(key, prefix);\r\n        }\r\n        resolve(true);\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Gets the entry specified by the given key or null.\r\n   * @param key     Key identifying the wanted entry.\r\n   * @param prefixOrSerializer  Optional prefix or serializer to overwrite the configured one.\r\n   * @param serializer  Optional serilizer.\r\n   */\r\n  public get(key: string, prefixOrSerializer?: string | StorageSerializer): Promise<any | null | undefined>;\r\n  public get(key: string, prefixOrSerializer: string | StorageSerializer): Promise<any | null | undefined>;\r\n  public get(key: string, prefixOrSerializer: string, serializer: StorageSerializer): Promise<any | null | undefined>;\r\n  public get(key: string, prefixOrSerializer?: string | StorageSerializer, serializer?: StorageSerializer): Promise<any | null | undefined> {\r\n    return new Promise<any | null | undefined>((resolve, reject) => {\r\n      try {\r\n\r\n        const prefix = typeof prefixOrSerializer === 'string' ? prefixOrSerializer : undefined;\r\n        serializer = isSerializer(prefixOrSerializer)\r\n          ? (prefixOrSerializer as StorageSerializer)\r\n          : !!serializer\r\n            ? serializer\r\n            : this.defaultSerializer;\r\n\r\n        resolve(serializer.deserialize(localStorage.getItem(constructKey(key, prefix, this.configuration.prefix))));\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Removes the entry specified by the given key.\r\n   * @param key     Key identifying the entry to remove.\r\n   * @param prefix  Optional prefix to overwrite the configured one.\r\n   */\r\n  public remove(key: string, prefix?: string): Promise<boolean> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        localStorage.removeItem(constructKey(key, prefix, this.configuration.prefix));\r\n        resolve(true);\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Clears all entries of the applications local storage.\r\n   */\r\n  public clear(): Promise<boolean> {\r\n    return new Promise((resolve, reject) => {\r\n      try {\r\n        localStorage.clear();\r\n        resolve(true);\r\n      } catch (error) {\r\n        reject(error);\r\n      }\r\n    });\r\n  }\r\n}\r\n","import { InjectionToken } from '@angular/core';\r\nimport { NgxLocalstorageConfiguration } from '../interfaces/storage-configuration';\r\n\r\n/**\r\n * Provides an injection token for the service configuration.\r\n */\r\nexport const NGX_LOCAL_STORAGE_CONFIG = new InjectionToken<NgxLocalstorageConfiguration>('NgxLocalstorageConfiguration');","import { InjectionToken } from '@angular/core';\r\nimport { StorageSerializer } from '../interfaces/storage-serializer';\r\n\r\n/**\r\n * Provides an injection token for the services serializer.\r\n */\r\nexport const NGX_LOCAL_STORAGE_SERIALIZER = new InjectionToken<StorageSerializer>('StorageSerializer');","import { Injectable, Inject } from '@angular/core';\r\n\r\nimport { NgxLocalstorageConfiguration } from '../interfaces/storage-configuration';\r\nimport { PromisableService } from './promisable.service';\r\nimport { defaultConfig, constructKey, isSerializer } from '../utils';\r\nimport { NGX_LOCAL_STORAGE_CONFIG } from '../tokens/storage-config';\r\nimport { NGX_LOCAL_STORAGE_SERIALIZER } from '../tokens/storage-serializer';\r\nimport { StorageSerializer } from '../interfaces/storage-serializer';\r\n\r\n/**\r\n * Provides a service to access the localstorage.\r\n */\r\n@Injectable({ providedIn: 'root' })\r\nexport class LocalStorageService {\r\n\r\n  private readonly promisable: PromisableService;\r\n\r\n  /**\r\n   * Creates a new instance.\r\n   */\r\n  constructor(\r\n    @Inject(NGX_LOCAL_STORAGE_SERIALIZER) private readonly defaultSerializer: StorageSerializer,\r\n    @Inject(NGX_LOCAL_STORAGE_CONFIG) public readonly config?: NgxLocalstorageConfiguration\r\n  ) {\r\n    this.config = { ...defaultConfig, ...config };\r\n\r\n    this.promisable = new PromisableService(this.config, this.defaultSerializer);\r\n  }\r\n\r\n  /**\r\n   * Returns a service variant based on Promises.\r\n   */\r\n  public asPromisable(): PromisableService {\r\n    return this.promisable;\r\n  }\r\n\r\n  /**\r\n   * Gets the number of entries in the applications local storage.\r\n   */\r\n  public count(): number | undefined {\r\n    try {\r\n      return localStorage.length;\r\n    } catch (error) {\r\n      console.error(error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns the nth (defined by the index parameter) key in the storage.\r\n   * The order of keys is user-agent defined, so you should not rely on it.\r\n   * @param index   An integer representing the number of the key you want to get the name of. This is a zero-based index.\r\n   */\r\n  public getKey(index: number): string | null | undefined {\r\n    if (index < 0) {\r\n      console.error(new Error('index has to be 0 or greater'));\r\n    }\r\n    try {\r\n      return localStorage.key(index);\r\n    } catch (error) {\r\n      console.error(error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adds the value with the given key or updates an existing entry.\r\n   * @param key     Key to store.\r\n   * @param value   Value to store.\r\n   * @param prefixOrSerializer  Optional prefix or serializer to overwrite the configured one.\r\n   */\r\n  public set(key: string, value: any, prefixOrSerializer?: string | StorageSerializer): void;\r\n  /**\r\n   * Adds the value with the given key or updates an existing entry.\r\n   * @param key     Key to store.\r\n   * @param value   Value to store.\r\n   * @param prefixOrSerializer  prefix or serializer to overwrite the configured one.\r\n   */\r\n  public set(key: string, value: any, prefixOrSerializer: string | StorageSerializer): void;\r\n  /**\r\n   * Adds the value with the given key or updates an existing entry.\r\n   * @param key     Key to store.\r\n   * @param value   Value to store.\r\n   * @param prefix  Optional prefix to overwrite the configured one.\r\n   * @param serializer  Optional serilizer.\r\n   */\r\n  public set(key: string, value: any, prefix: string, serializer: StorageSerializer): void;\r\n  /**\r\n   * Adds the value with the given key or updates an existing entry.\r\n   * @param key     Key to store.\r\n   * @param value   Value to store.\r\n   * @param prefixOrSerializer  Optional prefix or serializer to overwrite the configured one.\r\n   * @param serializer  Optional serilizer.\r\n   */\r\n  public set(key: string, value: any, prefixOrSerializer?: string | StorageSerializer, serializer?: StorageSerializer): void {\r\n\r\n    const prefix = typeof prefixOrSerializer === 'string' ? prefixOrSerializer : undefined;\r\n    serializer = isSerializer(prefixOrSerializer)\r\n      ? (prefixOrSerializer as StorageSerializer)\r\n      : !!serializer\r\n        ? serializer\r\n        : this.defaultSerializer;\r\n\r\n    if (\r\n      this.config.allowNull ||\r\n      (!this.config.allowNull &&\r\n        value !== 'null' &&\r\n        value !== null &&\r\n        value !== undefined)\r\n    ) {\r\n      localStorage.setItem(constructKey(key, prefix, this.config.prefix), serializer.serialize(value));\r\n    } else {\r\n      this.remove(key, constructKey(key, prefix, this.config.prefix));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the entry specified by the given key or null.\r\n   * @param key     Key identifying the wanted entry.\r\n   * @param prefixOrSerializer  Optional prefix or serializer to overwrite the configured one.\r\n   * @param serializer  Optional serilizer.\r\n   */\r\n  public get(key: string, prefixOrSerializer?: string | StorageSerializer): any | null | undefined;\r\n  /**\r\n   * Gets the entry specified by the given key or null.\r\n   * @param key     Key identifying the wanted entry.\r\n   * @param prefixOrSerializer  prefix or serializer to overwrite the configured one.\r\n   */\r\n  public get(key: string, prefixOrSerializer: string | StorageSerializer): any | null | undefined;\r\n  /**\r\n   * Gets the entry specified by the given key or null.\r\n   * @param key     Key identifying the wanted entry.\r\n   * @param prefix  prefix or serializer to overwrite the configured one.\r\n   * @param serializer serilizer.\r\n   */\r\n  public get(key: string, prefix: string, serializer: StorageSerializer): any | null | undefined;\r\n  /**\r\n   * Gets the entry specified by the given key or null.\r\n   * @param key     Key identifying the wanted entry.\r\n   * @param prefixOrSerializer  Optional prefix or serializer to overwrite the configured one.\r\n   * @param serializer  Optional serilizer.\r\n   */\r\n  public get(key: string, prefixOrSerializer?: string | StorageSerializer, serializer?: StorageSerializer): any | null | undefined {\r\n\r\n    const prefix = typeof prefixOrSerializer === 'string' ? prefixOrSerializer : undefined;\r\n    serializer = isSerializer(prefixOrSerializer)\r\n      ? (prefixOrSerializer as StorageSerializer)\r\n      : !!serializer\r\n        ? serializer\r\n        : this.defaultSerializer;\r\n\r\n    try {\r\n      return serializer.deserialize(localStorage.getItem(constructKey(key, prefix, this.config.prefix)));\r\n    } catch (error) {\r\n      console.error(error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Removes the entry specified by the given key.\r\n   * @param key     Key identifying the entry to remove.\r\n   * @param prefix  Optional prefix to overwrite the configured one.\r\n   */\r\n  public remove(key: string, prefix?: string): void {\r\n    try {\r\n      localStorage.removeItem(constructKey(key, prefix, this.config.prefix));\r\n    } catch (error) {\r\n      console.error(error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clears all entries of the applications local storage.\r\n   */\r\n  public clear(): void {\r\n    try {\r\n      localStorage.clear();\r\n    } catch (error) {\r\n      console.error(error);\r\n    }\r\n  }\r\n}\r\n","import { Injectable, OnDestroy } from '@angular/core';\r\nimport { fromEvent as observableFromEvent, BehaviorSubject, Observable, Subscription } from 'rxjs';\r\nimport { share, filter } from 'rxjs/operators';\r\n\r\n/**\r\n * Provides a service\r\n */\r\n@Injectable({ providedIn: 'root' })\r\nexport class StorageEventService implements OnDestroy {\r\n\r\n  private readonly _eventStream: BehaviorSubject<StorageEvent> = new BehaviorSubject<StorageEvent>(null);\r\n  private readonly subscription: Subscription;\r\n\r\n  /**\r\n   * Create e new instance.\r\n   */\r\n  constructor() {\r\n    this.subscription = observableFromEvent(window, 'storage')\r\n      .subscribe((ev: StorageEvent) => this._eventStream.next(ev));\r\n  }\r\n\r\n  /**\r\n   * Gets a stream of storage events.\r\n   */\r\n  public get stream(): Observable<StorageEvent> {\r\n    return this._eventStream\r\n      .asObservable().pipe(\r\n        filter(ev => !!ev),\r\n        share()\r\n      );\r\n  }\r\n\r\n  /**\r\n   * OnDestroy lifecycle hook. Clears the subscription.\r\n   */\r\n  public ngOnDestroy(): void {\r\n    if (!!this.subscription && !this.subscription.closed) {\r\n      this.subscription.unsubscribe();\r\n    }\r\n  }\r\n}\r\n","import { AfterViewInit, Directive, ElementRef, EventEmitter, Input, OnDestroy, Output } from '@angular/core';\r\nimport { fromEvent as observableFromEvent, Subscription } from 'rxjs';\r\nimport { debounceTime, filter } from 'rxjs/operators';\r\n\r\nimport { getProperty, setProperty } from '../utils';\r\nimport { LocalStorageService } from '../services/ngx-localstorage.service';\r\nimport { StorageEventService } from '../services/storage-event.service';\r\n\r\n/**\r\n * Provide a directive to directly interact with stored values.\r\n */\r\n@Directive({\r\n  selector: '[ngxLocalStorage]'\r\n})\r\nexport class LocalStorageDirective implements AfterViewInit, OnDestroy {\r\n\r\n  /**\r\n   * The key to use with localstorage.\r\n   */\r\n  @Input('ngxLocalStorage')\r\n  public lsKey: string;\r\n  /**\r\n   * The keys prefix to use.\r\n   */\r\n  @Input()\r\n  public lsPrefix: string;\r\n  /**\r\n   * The event to hook onto value changes.\r\n   */\r\n  @Input()\r\n  public lsEvent: string;\r\n  /**\r\n   * An optional debounce for storage write access after value changes.\r\n   */\r\n  @Input()\r\n  public lsDebounce = 0;\r\n  /**\r\n   * Flag if the bound elements value should be initialized from storage.\r\n   */\r\n  @Input()\r\n  public lsInitFromStorage = false;\r\n  /**\r\n   * An optional transformer to handle falsy values.\r\n   */\r\n  @Input()\r\n  public lsFalsyTransformer?: () => any;\r\n\r\n  /**\r\n   * Provides a path to access the bound elements value property.\r\n   */\r\n  @Input()\r\n  public set lsValuePath(path: any[] | string) {\r\n    if (path != null) {\r\n      this._valuePath = Array.isArray(path) ? path : path.split(',');\r\n    } else {\r\n      this._valuePath = [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Event which gets fired when a bound value got stored.\r\n   */\r\n  @Output()\r\n  public lsStoredValue = new EventEmitter<any>();\r\n\r\n  private _eventSubscription: Subscription;\r\n  private _valuePath: string[] = [];\r\n\r\n  /**\r\n   * Creates a new instance.\r\n   */\r\n  constructor(private readonly er: ElementRef,\r\n    private readonly lss: LocalStorageService,\r\n    private readonly es: StorageEventService) {\r\n\r\n    this.es.stream.pipe(\r\n      // TODO: filter should be more accurate\r\n      filter((ev: StorageEvent) => ev.key && ev.key.indexOf(this.lsKey) >= 0)\r\n    )\r\n      .subscribe((ev: StorageEvent) => {\r\n        setProperty(this._valuePath.length ? this._valuePath : ['value'], ev.newValue, this.er.nativeElement, this.lsFalsyTransformer);\r\n      });\r\n  }\r\n\r\n  /**\r\n   * AfterViewInit lifecycle hook.\r\n   */\r\n  public ngAfterViewInit(): void {\r\n    this._initKey();\r\n    this._initFromStorage();\r\n    this._hookEvent();\r\n  }\r\n\r\n  /**\r\n   * Initalizes the from either the given value or the elements id or name property.\r\n   */\r\n  private _initKey(): void {\r\n    if (!this.lsKey) {\r\n      if (!this.er.nativeElement.id && !this.er.nativeElement.name) {\r\n        throw new Error('No key or element id or name supplied!');\r\n      }\r\n      this.lsKey = this.er.nativeElement.id || this.er.nativeElement.name;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Hooks onto the elements given event to perform storage write on value changes.\r\n   */\r\n  private _hookEvent(): void {\r\n    if (this.lsEvent) {\r\n      this._eventSubscription = observableFromEvent(this.er.nativeElement, this.lsEvent).pipe(\r\n        debounceTime(this.lsDebounce))\r\n        .subscribe(() => {\r\n          this.lss.asPromisable().set(this.lsKey,\r\n            getProperty(this._valuePath.length ? this._valuePath : ['value'], this.er.nativeElement),\r\n            this.lsPrefix)\r\n            .then(() => {\r\n              this.lss.asPromisable().get(this.lsKey, this.lsPrefix)\r\n                .then((value: any) => {\r\n                  this.lsStoredValue.emit(value);\r\n                })\r\n                .catch((err: Error) => console.error(err));\r\n            })\r\n            .catch((err: Error) => console.error(err));\r\n        });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initializes the elements value from storage.\r\n   */\r\n  private _initFromStorage(): void {\r\n    if (this.lsInitFromStorage) {\r\n      this.lss.asPromisable().get(this.lsKey, this.lsPrefix)\r\n        .then((storedValue: any) => {\r\n          setProperty(this._valuePath.length ? this._valuePath : ['value'], storedValue, this.er.nativeElement, this.lsFalsyTransformer);\r\n        })\r\n        .catch((err: Error) => console.error(err));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Unsubscribe from event observable.\r\n   */\r\n  public ngOnDestroy(): void {\r\n    if (this._eventSubscription && !this._eventSubscription.closed) {\r\n      this._eventSubscription.unsubscribe();\r\n    }\r\n  }\r\n}\r\n","import { StorageSerializer } from '../interfaces/storage-serializer';\r\nimport { Injectable } from \"@angular/core\";\r\n\r\n/**\r\n * Provides a default serialization mechanism while\r\n */\r\n@Injectable()\r\nexport class DefaultSerializer implements StorageSerializer {\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public serialize(value: any): string {\r\n        return JSON.stringify(value);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    public deserialize(storedValue: string): any {\r\n        return JSON.parse(storedValue);\r\n    }\r\n}","import { ModuleWithProviders, NgModule, Optional, SkipSelf } from '@angular/core';\r\n\r\nimport { NgxLocalstorageConfiguration } from './interfaces/storage-configuration';\r\nimport { LocalStorageDirective } from './directives/ngx-localstorage.directive';\r\nimport { NGX_LOCAL_STORAGE_CONFIG } from './tokens/storage-config';\r\nimport { DefaultSerializer } from './classes/default-serializer';\r\nimport { NGX_LOCAL_STORAGE_SERIALIZER } from './tokens/storage-serializer';\r\n\r\n/**\r\n * Provides the librarys module.\r\n */\r\n@NgModule({\r\n  imports: [\r\n  ],\r\n  declarations: [\r\n    LocalStorageDirective\r\n  ],\r\n  exports: [\r\n    LocalStorageDirective\r\n  ],\r\n  providers: [\r\n    {\r\n      provide: NGX_LOCAL_STORAGE_SERIALIZER,\r\n      useClass: DefaultSerializer\r\n    }\r\n  ]\r\n})\r\nexport class NgxLocalStorageModule {\r\n\r\n  /**\r\n   * Initializes the module for the root module with the given configuration.\r\n   */\r\n  public static forRoot(config?: NgxLocalstorageConfiguration): ModuleWithProviders<NgxLocalStorageModule> {\r\n    return {\r\n      ngModule: NgxLocalStorageModule,\r\n      providers: [\r\n        {\r\n          provide: NGX_LOCAL_STORAGE_CONFIG,\r\n          useValue: config\r\n        }\r\n      ]\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Creates a new instance.\r\n   */\r\n  constructor(@Optional() @SkipSelf() parentModule: NgxLocalStorageModule) {\r\n    if (parentModule) {\r\n      throw new Error('NgxLocalStorageModule is already loaded. Import it in the AppModule only');\r\n    }\r\n  }\r\n}\r\n","import { filter } from 'rxjs/operators';\r\n\r\nimport { DecoratorOpts } from './interfaces/decorator-options';\r\nimport { LocalStorageService } from './services/ngx-localstorage.service';\r\nimport { StorageEventService } from './services/storage-event.service';\r\nimport { constructKey } from './utils';\r\nimport { DefaultSerializer } from './classes/default-serializer';\r\n\r\n/**\r\n * Provides a decoarator to bind a property directly to a storage value.\r\n * @param options configuration used for the decoarator\r\n */\r\nexport function ngxLocalStorage(options?: DecoratorOpts) {\r\n  return function (target: Object, propertyDescription: string) {\r\n\r\n    const key = !!options && !!options.key ? options.key : propertyDescription;\r\n    const prefix = !!options && !!options.prefix ? options.prefix : null;\r\n\r\n    const service: LocalStorageService = new LocalStorageService(new DefaultSerializer(),\r\n      {\r\n        prefix: prefix\r\n      });\r\n\r\n\r\n    const eventService: StorageEventService = new StorageEventService();\r\n    eventService.stream.pipe(\r\n      // TODO: filter should be more accurate\r\n      filter((ev: StorageEvent) => ev.key && ev.key.indexOf(constructKey(key, prefix)) >= 0)\r\n    )\r\n      .subscribe((ev: StorageEvent) => {\r\n        if (!!ev.newValue && typeof ev.newValue === 'string') {\r\n          if (ev.newValue !== 'null') {\r\n            target[propertyDescription] = ev.newValue;\r\n          } else {\r\n            target[propertyDescription] = !!options.nullTransformer ? options.nullTransformer() : null;\r\n          }\r\n        }\r\n      });\r\n\r\n    Object.defineProperty(target, propertyDescription, {\r\n      get: function () {\r\n        const storageValue = service.get(key, prefix);\r\n        return storageValue == null && !!options.nullTransformer ? options.nullTransformer() : storageValue;\r\n      },\r\n      set: function (value: any) {\r\n        service.set(key, value, prefix);\r\n      }\r\n    });\r\n  };\r\n}\r\n"]}