(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('ngx-localstorage', ['exports', '@angular/core', 'rxjs', 'rxjs/operators'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['ngx-localstorage'] = {}, global.ng.core, global.rxjs, global.rxjs.operators));
}(this, (function (exports, i0, rxjs, operators) { 'use strict';

    /**
     * Gets an objects property based on its path.
     * @param path Path to the property
     * @param object Object to access
     */
    var getProperty = function (path, object) { return path.reduce(function (obj, p) { return (!!obj) ? obj[p] : null; }, object); };
    /**
     * Sets an objects property based on its path.
     * @param path Path to the property
     * @param value Value to set
     * @param object Object whose value to set
     * @param falsyTransformer optional transformer handling falsy values
     */
    var setProperty = function (path, value, object, falsyTransformer) {
        var lastKeyIndex = path.length - 1;
        for (var i = 0; i < lastKeyIndex; ++i) {
            var key = path[i];
            if (!(key in object)) {
                object[key] = {};
            }
            object = object[key];
        }
        object[path[lastKeyIndex]] = (!value || (typeof value === 'string' && value === 'false'))
            && !!falsyTransformer ? falsyTransformer() : value;
    };
    /**
     * Constructs the storage key based on a prefix - if given - and the key itself
     */
    var constructKey = function (key, prefix, configuredPrefix) {
        var prefixToUse = prefix || configuredPrefix;
        if (prefixToUse) {
            return prefixToUse + "_" + key;
        }
        return key;
    };
    /**
     * The librarys default config.
     */
    var defaultConfig = {
        allowNull: true
    };
    /**
     * StorageSerializer Guard
     */
    var isSerializer = function (prefixOrSerializer) {
        return !!prefixOrSerializer && prefixOrSerializer.serialize !== undefined;
    };

    /**
     * Provides a Promise based service to access the localstorage.
     */
    var PromisableService = /** @class */ (function () {
        /**
         * Creates a new instance
         */
        function PromisableService(configuration, defaultSerializer) {
            this.configuration = configuration;
            this.defaultSerializer = defaultSerializer;
        }
        /**
         * Gets the number of entries in the applications local storage.
         */
        PromisableService.prototype.count = function () {
            return new Promise(function (resolve, reject) {
                try {
                    resolve(localStorage.length);
                }
                catch (error) {
                    reject(error);
                }
            });
        };
        /**
         * Returns the nth (defined by the index parameter) key in the storage.
         * The order of keys is user-agent defined, so you should not rely on it.
         * @param index   An integer representing the number of the key you want to get the name of. This is a zero-based index.
         */
        PromisableService.prototype.getKey = function (index) {
            return new Promise(function (resolve, reject) {
                if (index < 0) {
                    reject(new Error('index has to be 0 or greater'));
                }
                try {
                    resolve(localStorage.key(index));
                }
                catch (error) {
                    reject(error);
                }
            });
        };
        PromisableService.prototype.set = function (key, value, prefixOrSerializer, serializer) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                try {
                    var prefix = typeof prefixOrSerializer === 'string' ? prefixOrSerializer : undefined;
                    serializer = isSerializer(prefixOrSerializer)
                        ? prefixOrSerializer
                        : !!serializer
                            ? serializer
                            : _this.defaultSerializer;
                    if (_this.configuration.allowNull
                        || (!_this.configuration.allowNull && value !== 'null' && value !== null && value !== undefined)) {
                        localStorage.setItem(constructKey(key, prefix, _this.configuration.prefix), serializer.serialize(value));
                    }
                    else {
                        return _this.remove(key, prefix);
                    }
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            });
        };
        PromisableService.prototype.get = function (key, prefixOrSerializer, serializer) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                try {
                    var prefix = typeof prefixOrSerializer === 'string' ? prefixOrSerializer : undefined;
                    serializer = isSerializer(prefixOrSerializer)
                        ? prefixOrSerializer
                        : !!serializer
                            ? serializer
                            : _this.defaultSerializer;
                    resolve(serializer.deserialize(localStorage.getItem(constructKey(key, prefix, _this.configuration.prefix))));
                }
                catch (error) {
                    reject(error);
                }
            });
        };
        /**
         * Removes the entry specified by the given key.
         * @param key     Key identifying the entry to remove.
         * @param prefix  Optional prefix to overwrite the configured one.
         */
        PromisableService.prototype.remove = function (key, prefix) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                try {
                    localStorage.removeItem(constructKey(key, prefix, _this.configuration.prefix));
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            });
        };
        /**
         * Clears all entries of the applications local storage.
         */
        PromisableService.prototype.clear = function () {
            return new Promise(function (resolve, reject) {
                try {
                    localStorage.clear();
                    resolve(true);
                }
                catch (error) {
                    reject(error);
                }
            });
        };
        return PromisableService;
    }());

    /**
     * Provides an injection token for the service configuration.
     */
    var NGX_LOCAL_STORAGE_CONFIG = new i0.InjectionToken('NgxLocalstorageConfiguration');

    /**
     * Provides an injection token for the services serializer.
     */
    var NGX_LOCAL_STORAGE_SERIALIZER = new i0.InjectionToken('StorageSerializer');

    /**
     * Provides a service to access the localstorage.
     */
    var LocalStorageService = /** @class */ (function () {
        /**
         * Creates a new instance.
         */
        function LocalStorageService(defaultSerializer, config) {
            this.defaultSerializer = defaultSerializer;
            this.config = config;
            this.config = Object.assign(Object.assign({}, defaultConfig), config);
            this.promisable = new PromisableService(this.config, this.defaultSerializer);
        }
        /**
         * Returns a service variant based on Promises.
         */
        LocalStorageService.prototype.asPromisable = function () {
            return this.promisable;
        };
        /**
         * Gets the number of entries in the applications local storage.
         */
        LocalStorageService.prototype.count = function () {
            try {
                return localStorage.length;
            }
            catch (error) {
                console.error(error);
            }
        };
        /**
         * Returns the nth (defined by the index parameter) key in the storage.
         * The order of keys is user-agent defined, so you should not rely on it.
         * @param index   An integer representing the number of the key you want to get the name of. This is a zero-based index.
         */
        LocalStorageService.prototype.getKey = function (index) {
            if (index < 0) {
                console.error(new Error('index has to be 0 or greater'));
            }
            try {
                return localStorage.key(index);
            }
            catch (error) {
                console.error(error);
            }
        };
        /**
         * Adds the value with the given key or updates an existing entry.
         * @param key     Key to store.
         * @param value   Value to store.
         * @param prefixOrSerializer  Optional prefix or serializer to overwrite the configured one.
         * @param serializer  Optional serilizer.
         */
        LocalStorageService.prototype.set = function (key, value, prefixOrSerializer, serializer) {
            var prefix = typeof prefixOrSerializer === 'string' ? prefixOrSerializer : undefined;
            serializer = isSerializer(prefixOrSerializer)
                ? prefixOrSerializer
                : !!serializer
                    ? serializer
                    : this.defaultSerializer;
            if (this.config.allowNull ||
                (!this.config.allowNull &&
                    value !== 'null' &&
                    value !== null &&
                    value !== undefined)) {
                localStorage.setItem(constructKey(key, prefix, this.config.prefix), serializer.serialize(value));
            }
            else {
                this.remove(key, constructKey(key, prefix, this.config.prefix));
            }
        };
        /**
         * Gets the entry specified by the given key or null.
         * @param key     Key identifying the wanted entry.
         * @param prefixOrSerializer  Optional prefix or serializer to overwrite the configured one.
         * @param serializer  Optional serilizer.
         */
        LocalStorageService.prototype.get = function (key, prefixOrSerializer, serializer) {
            var prefix = typeof prefixOrSerializer === 'string' ? prefixOrSerializer : undefined;
            serializer = isSerializer(prefixOrSerializer)
                ? prefixOrSerializer
                : !!serializer
                    ? serializer
                    : this.defaultSerializer;
            try {
                return serializer.deserialize(localStorage.getItem(constructKey(key, prefix, this.config.prefix)));
            }
            catch (error) {
                console.error(error);
            }
        };
        /**
         * Removes the entry specified by the given key.
         * @param key     Key identifying the entry to remove.
         * @param prefix  Optional prefix to overwrite the configured one.
         */
        LocalStorageService.prototype.remove = function (key, prefix) {
            try {
                localStorage.removeItem(constructKey(key, prefix, this.config.prefix));
            }
            catch (error) {
                console.error(error);
            }
        };
        /**
         * Clears all entries of the applications local storage.
         */
        LocalStorageService.prototype.clear = function () {
            try {
                localStorage.clear();
            }
            catch (error) {
                console.error(error);
            }
        };
        return LocalStorageService;
    }());
    LocalStorageService.ɵprov = i0.ɵɵdefineInjectable({ factory: function LocalStorageService_Factory() { return new LocalStorageService(i0.ɵɵinject(NGX_LOCAL_STORAGE_SERIALIZER), i0.ɵɵinject(NGX_LOCAL_STORAGE_CONFIG)); }, token: LocalStorageService, providedIn: "root" });
    LocalStorageService.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];
    LocalStorageService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [NGX_LOCAL_STORAGE_SERIALIZER,] }] },
        { type: undefined, decorators: [{ type: i0.Inject, args: [NGX_LOCAL_STORAGE_CONFIG,] }] }
    ]; };

    /**
     * Provides a service
     */
    var StorageEventService = /** @class */ (function () {
        /**
         * Create e new instance.
         */
        function StorageEventService() {
            var _this = this;
            this._eventStream = new rxjs.BehaviorSubject(null);
            this.subscription = rxjs.fromEvent(window, 'storage')
                .subscribe(function (ev) { return _this._eventStream.next(ev); });
        }
        Object.defineProperty(StorageEventService.prototype, "stream", {
            /**
             * Gets a stream of storage events.
             */
            get: function () {
                return this._eventStream
                    .asObservable().pipe(operators.filter(function (ev) { return !!ev; }), operators.share());
            },
            enumerable: false,
            configurable: true
        });
        /**
         * OnDestroy lifecycle hook. Clears the subscription.
         */
        StorageEventService.prototype.ngOnDestroy = function () {
            if (!!this.subscription && !this.subscription.closed) {
                this.subscription.unsubscribe();
            }
        };
        return StorageEventService;
    }());
    StorageEventService.ɵprov = i0.ɵɵdefineInjectable({ factory: function StorageEventService_Factory() { return new StorageEventService(); }, token: StorageEventService, providedIn: "root" });
    StorageEventService.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];
    StorageEventService.ctorParameters = function () { return []; };

    /**
     * Provide a directive to directly interact with stored values.
     */
    var LocalStorageDirective = /** @class */ (function () {
        /**
         * Creates a new instance.
         */
        function LocalStorageDirective(er, lss, es) {
            var _this = this;
            this.er = er;
            this.lss = lss;
            this.es = es;
            /**
             * An optional debounce for storage write access after value changes.
             */
            this.lsDebounce = 0;
            /**
             * Flag if the bound elements value should be initialized from storage.
             */
            this.lsInitFromStorage = false;
            /**
             * Event which gets fired when a bound value got stored.
             */
            this.lsStoredValue = new i0.EventEmitter();
            this._valuePath = [];
            this.es.stream.pipe(
            // TODO: filter should be more accurate
            operators.filter(function (ev) { return ev.key && ev.key.indexOf(_this.lsKey) >= 0; }))
                .subscribe(function (ev) {
                setProperty(_this._valuePath.length ? _this._valuePath : ['value'], ev.newValue, _this.er.nativeElement, _this.lsFalsyTransformer);
            });
        }
        Object.defineProperty(LocalStorageDirective.prototype, "lsValuePath", {
            /**
             * Provides a path to access the bound elements value property.
             */
            set: function (path) {
                if (path != null) {
                    this._valuePath = Array.isArray(path) ? path : path.split(',');
                }
                else {
                    this._valuePath = [];
                }
            },
            enumerable: false,
            configurable: true
        });
        /**
         * AfterViewInit lifecycle hook.
         */
        LocalStorageDirective.prototype.ngAfterViewInit = function () {
            this._initKey();
            this._initFromStorage();
            this._hookEvent();
        };
        /**
         * Initalizes the from either the given value or the elements id or name property.
         */
        LocalStorageDirective.prototype._initKey = function () {
            if (!this.lsKey) {
                if (!this.er.nativeElement.id && !this.er.nativeElement.name) {
                    throw new Error('No key or element id or name supplied!');
                }
                this.lsKey = this.er.nativeElement.id || this.er.nativeElement.name;
            }
        };
        /**
         * Hooks onto the elements given event to perform storage write on value changes.
         */
        LocalStorageDirective.prototype._hookEvent = function () {
            var _this = this;
            if (this.lsEvent) {
                this._eventSubscription = rxjs.fromEvent(this.er.nativeElement, this.lsEvent).pipe(operators.debounceTime(this.lsDebounce))
                    .subscribe(function () {
                    _this.lss.asPromisable().set(_this.lsKey, getProperty(_this._valuePath.length ? _this._valuePath : ['value'], _this.er.nativeElement), _this.lsPrefix)
                        .then(function () {
                        _this.lss.asPromisable().get(_this.lsKey, _this.lsPrefix)
                            .then(function (value) {
                            _this.lsStoredValue.emit(value);
                        })
                            .catch(function (err) { return console.error(err); });
                    })
                        .catch(function (err) { return console.error(err); });
                });
            }
        };
        /**
         * Initializes the elements value from storage.
         */
        LocalStorageDirective.prototype._initFromStorage = function () {
            var _this = this;
            if (this.lsInitFromStorage) {
                this.lss.asPromisable().get(this.lsKey, this.lsPrefix)
                    .then(function (storedValue) {
                    setProperty(_this._valuePath.length ? _this._valuePath : ['value'], storedValue, _this.er.nativeElement, _this.lsFalsyTransformer);
                })
                    .catch(function (err) { return console.error(err); });
            }
        };
        /**
         * Unsubscribe from event observable.
         */
        LocalStorageDirective.prototype.ngOnDestroy = function () {
            if (this._eventSubscription && !this._eventSubscription.closed) {
                this._eventSubscription.unsubscribe();
            }
        };
        return LocalStorageDirective;
    }());
    LocalStorageDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[ngxLocalStorage]'
                },] }
    ];
    LocalStorageDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: LocalStorageService },
        { type: StorageEventService }
    ]; };
    LocalStorageDirective.propDecorators = {
        lsKey: [{ type: i0.Input, args: ['ngxLocalStorage',] }],
        lsPrefix: [{ type: i0.Input }],
        lsEvent: [{ type: i0.Input }],
        lsDebounce: [{ type: i0.Input }],
        lsInitFromStorage: [{ type: i0.Input }],
        lsFalsyTransformer: [{ type: i0.Input }],
        lsValuePath: [{ type: i0.Input }],
        lsStoredValue: [{ type: i0.Output }]
    };

    /**
     * Provides a default serialization mechanism while
     */
    var DefaultSerializer = /** @class */ (function () {
        function DefaultSerializer() {
        }
        /**
         * @inheritdoc
         */
        DefaultSerializer.prototype.serialize = function (value) {
            return JSON.stringify(value);
        };
        /**
         * @inheritdoc
         */
        DefaultSerializer.prototype.deserialize = function (storedValue) {
            return JSON.parse(storedValue);
        };
        return DefaultSerializer;
    }());
    DefaultSerializer.decorators = [
        { type: i0.Injectable }
    ];

    /**
     * Provides the librarys module.
     */
    var NgxLocalStorageModule = /** @class */ (function () {
        /**
         * Creates a new instance.
         */
        function NgxLocalStorageModule(parentModule) {
            if (parentModule) {
                throw new Error('NgxLocalStorageModule is already loaded. Import it in the AppModule only');
            }
        }
        /**
         * Initializes the module for the root module with the given configuration.
         */
        NgxLocalStorageModule.forRoot = function (config) {
            return {
                ngModule: NgxLocalStorageModule,
                providers: [
                    {
                        provide: NGX_LOCAL_STORAGE_CONFIG,
                        useValue: config
                    }
                ]
            };
        };
        return NgxLocalStorageModule;
    }());
    NgxLocalStorageModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [],
                    declarations: [
                        LocalStorageDirective
                    ],
                    exports: [
                        LocalStorageDirective
                    ],
                    providers: [
                        {
                            provide: NGX_LOCAL_STORAGE_SERIALIZER,
                            useClass: DefaultSerializer
                        }
                    ]
                },] }
    ];
    NgxLocalStorageModule.ctorParameters = function () { return [
        { type: NgxLocalStorageModule, decorators: [{ type: i0.Optional }, { type: i0.SkipSelf }] }
    ]; };

    /**
     * Provides a decoarator to bind a property directly to a storage value.
     * @param options configuration used for the decoarator
     */
    function ngxLocalStorage(options) {
        return function (target, propertyDescription) {
            var key = !!options && !!options.key ? options.key : propertyDescription;
            var prefix = !!options && !!options.prefix ? options.prefix : null;
            var service = new LocalStorageService(new DefaultSerializer(), {
                prefix: prefix
            });
            var eventService = new StorageEventService();
            eventService.stream.pipe(
            // TODO: filter should be more accurate
            operators.filter(function (ev) { return ev.key && ev.key.indexOf(constructKey(key, prefix)) >= 0; }))
                .subscribe(function (ev) {
                if (!!ev.newValue && typeof ev.newValue === 'string') {
                    if (ev.newValue !== 'null') {
                        target[propertyDescription] = ev.newValue;
                    }
                    else {
                        target[propertyDescription] = !!options.nullTransformer ? options.nullTransformer() : null;
                    }
                }
            });
            Object.defineProperty(target, propertyDescription, {
                get: function () {
                    var storageValue = service.get(key, prefix);
                    return storageValue == null && !!options.nullTransformer ? options.nullTransformer() : storageValue;
                },
                set: function (value) {
                    service.set(key, value, prefix);
                }
            });
        };
    }

    /*
     * Public API Surface of ngx-localstorage
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.LocalStorageDirective = LocalStorageDirective;
    exports.LocalStorageService = LocalStorageService;
    exports.NGX_LOCAL_STORAGE_CONFIG = NGX_LOCAL_STORAGE_CONFIG;
    exports.NGX_LOCAL_STORAGE_SERIALIZER = NGX_LOCAL_STORAGE_SERIALIZER;
    exports.NgxLocalStorageModule = NgxLocalStorageModule;
    exports.StorageEventService = StorageEventService;
    exports.ngxLocalStorage = ngxLocalStorage;
    exports.ɵa = DefaultSerializer;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-localstorage.umd.js.map
